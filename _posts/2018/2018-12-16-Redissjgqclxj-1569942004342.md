---
layout: post
title:  "Redis数据过期策略详解"
categories: redis
tags: 过期策略
author: jiangc
excerpt: Redis数据过期策略详解
---
[**Redis学习笔记--Redis数据过期策略详解**](https://www.cnblogs.com/xuliangxing/p/7151812.html)

　　本文对Redis的过期机制简单的讲解一下

　　讲解之前我们先抛出一个问题，我们知道很多时候服务器经常会用到redis作为缓存，有很多数据都是临时缓存一下，可能用过之后很久都不会再用到了（比如暂存session，又或者只存放日行情股票数据）那么就会出现一下几个问题了

1. Redis会自己回收清理不用的数据吗？
2. 如果能，那如何配置？
3. 如果不能，如何防止数据累加后大量占用存储空间的问题？

　　之前一直接触Redis不是很深入，最近项目当中遇到一个需求场景，需要清空一些存放在Redis的数据，主要是通过一些时间进行过滤，删除那些不满足的数据，但是这样的工作每天都需要进行，那工作量就比较大了，而且每天都需要按时去手动清理，这样做也不切实际，后面发现Redis中有个设置时间过期的功能，即对存储在Redis数据库中的值可以设置一个过期时间。作为一个缓存数据库，这是非常实用的。这就是我们本文要讲到的Redis过期机制。其实这个机制运用的场景十分广泛，比如我们一般项目中的token或者一些登录信息，尤其是短信验证码都是有时间限制的，或者是限制请求次数，如果按照传统的数据库处理方式，一般都是自己判断过期，这样无疑会严重影响项目性能。

**一、设置过期时间**

　　Redis对存储值的过期处理实际上是针对该值的键（key）处理的，即时间的设置也是设置key的有效时间。Expires字典保存了所有键的过期时间，Expires也被称为过期字段。

1. expire key time(以秒为单位)--这是最常用的方式
2. setex(String key, int seconds, String value)--字符串独有的方式

注：

　　1、除了字符串自己独有设置过期时间的方法外，其他方法都需要依靠expire方法来设置时间

　　2、如果没有设置时间，那缓存就是永不过期

　　3、如果设置了过期时间，之后又想让缓存永不过期，使用persist key

**1、常用方式**

一般主要包括4种处理过期方，其中expire都是以秒为单位，pexpire都是以毫秒为单位的。

1 EXPIRE key seconds　　//将key的生存时间设置为ttl秒
2 PEXPIRE key milliseconds　　//将key的生成时间设置为ttl毫秒
3 EXPIREAT key timestamp　　//将key的过期时间设置为timestamp所代表的的秒数的时间戳
4 PEXPIREAT key milliseconds-timestamp　　//将key的过期时间设置为timestamp所代表的的毫秒数的时间戳

备注：timestamp为unix时间戳（例如：timestamp=1499788800 表示将在2017.07.12过期）

1、2两种方式是设置一个过期的时间段，就是咱们处理验证码最常用的策略，设置三分钟或五分钟后失效，把分钟数转换成秒或毫秒存储到Redis中。

3、4两种方式是指定一个过期的时间 ，比如优惠券的过期时间是某年某月某日，只是单位不一样。

下面我们就以EXPIREAT为例子简单讲解下用法。

**返回值**

一个整数值1或0，如下：

1. 如果成功地为该键设置了超时时间，返回 1
2. 如果键不存在或无法设置超时时间，返回 0

**语法**

以下是以Redis的EXPIREAT命令的基本语法。

1 redis 127.0.0.1:6379\&gt; Expireat KEY\_NAME TIME\_IN\_UNIX\_TIMESTAMP

**示例**

首先，在Redis中创建一个键：akey，并在akey中设置一些值。

1 redis 127.0.0.1:6379\&gt; SET akey redis
2 OK

现在，为设置创建的键设置超时时间为60 秒。

![image](/images/2018\12\redis\1569942004348.jpg "image")

 1127.0.0.1:6379\&gt; SET akey redis
 2 OK
 3127.0.0.1:6379\&gt; EXPIREAT akey 1393840000
 4 (integer) 1
 5127.0.0.1:6379\&gt; EXISTS akey
 6 (integer) 0
 7127.0.0.1:6379\&gt; SET akey redis
 8 OK
 9127.0.0.1:6379\&gt; EXPIREAT akey 1493840000
10 (integer) 1
11127.0.0.1:6379\&gt; EXISTS akey
12 (integer) 1

![image](/images/2018\12\redis\1569942004376.jpg "image")

![image](/images/2018\12\redis\1569942004388.jpg "image")

其他三个用法类似，这里不逐一阐述

**2、字符串独有方式**

对字符串特殊处理的方式为SETEX命令，SETEX命令为指定的 key 设置值及其过期时间。如果 key 已经存在， SETEX 命令将会替换旧的值。

**返回值**

设置成功时返回 OK 。

**语法**

Redis Setex 命令基本语法如下：

redis 127.0.0.1:6379\&gt; SETEX KEY\_NAME TIMEOUT VALUE

**示例**

1 redis 127.0.0.1:6379\&gt; SETEX mykey 60 redis
2 OK
3 redis 127.0.0.1:6379\&gt; TTL mykey
460
5 redis 127.0.0.1:6379\&gt; GET mykey
6&quot;redis

**二、3种过期策略**

1. **定时删除**

1.
  1. 含义：在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除
  2. 优点：保证内存被尽快释放
  3. 缺点：

1.
  1.
    1. 若过期key很多，删除这些key会占用很多的CPU时间，在CPU时间紧张的情况下，CPU不能把所有的时间用来做要紧的事儿，还需要去花时间删除这些key
    2. 定时器的创建耗时，若为每一个设置过期时间的key创建一个定时器（将会有大量的定时器产生），性能影响严重
    3. 没人用

1. **惰性删除**

1.
  1. 含义：key过期的时候不删除，每次从数据库获取key的时候去检查是否过期，若过期，则删除，返回null。
  2. 优点：删除操作只发生在从数据库取出key的时候发生，而且只删除当前key，所以对CPU时间的占用是比较少的，而且此时的删除是已经到了非做不可的地步（如果此时还不删除的话，我们就会获取到了已经过期的key了）
  3. 缺点：若大量的key在超出超时时间后，很久一段时间内，都没有被获取过，那么可能发生内存泄露（无用的垃圾占用了大量的内存）

1. **定期删除**

1.
  1. 含义：每隔一段时间执行一次删除(在redis.conf配置文件设置hz，1s刷新的频率)过期key操作
  2. 优点：

1.
  1.
    1. 通过限制删除操作的时长和频率，来减少删除操作对CPU时间的占用--处理&quot;定时删除&quot;的缺点
    2. 定期删除过期key--处理&quot;惰性删除&quot;的缺点

1.
  1. 缺点

1.
  1.
    1. 在内存友好方面，不如&quot;定时删除&quot;
    2. 在CPU时间友好方面，不如&quot;惰性删除&quot;

1.
  1. 难点

1.
  1.
    1. 合理设置删除操作的执行时长（每次删除执行多长时间）和执行频率（每隔多长时间做一次删除）（这个要根据服务器运行情况来定了）

看完上面三种策略后可以得出以下结论：

定时删除和定期删除为主动删除：Redis会定期主动淘汰一批已过去的key

惰性删除为被动删除：用到的时候才会去检验key是不是已过期，过期就删除

惰性删除为redis服务器内置策略

定期删除可以通过：

1. 第一、配置redis.conf 的hz选项，默认为10 （即1秒执行10次，100ms一次，值越大说明刷新频率越快，最Redis性能损耗也越大）
2. 第二、配置redis.conf的maxmemory最大值，当已用内存超过maxmemory限定时，就会触发主动清理策略

** 注意：**

1. 上边所说的数据库指的是内存数据库，默认情况下每一台redis服务器有16个数据库（关于数据库的设置，看下边代码），默认使用0号数据库，所有的操作都是对0号数据库的操作，关于redis数据库的存储结构，查看 第八章 Redis数据库结构与读写原理

# 设置数据库数量。默认为16个库，默认使用DB 0，可以使用&quot;select 1&quot;来选择一号数据库
# 注意：由于默认使用0号数据库，那么我们所做的所有的缓存操作都存在0号数据库上，
# 当你在1号数据库上去查找的时候，就查不到之前set过得缓存
# 若想将0号数据库上的缓存移动到1号数据库，可以使用&quot;move key 1&quot;
databases 16

1. memcached只是用了惰性删除，而Redis同时使用了惰性删除与定期删除，这也是二者的一个不同点（可以看做是redis优于memcached的一点）
2. 对于惰性删除而言，并不是只有获取key的时候才会检查key是否过期，在某些设置key的方法上也会检查（eg.setnx key2 value2：该方法类似于memcached的add方法，如果设置的key2已经存在，那么该方法返回false，什么都不做；如果设置的key2不存在，那么该方法设置缓存key2-value2。假设调用此方法的时候，发现redis中已经存在了key2，但是该key2已经过期了，如果此时不执行删除操作的话，setnx方法将会直接返回false，也就是说此时并没有重新设置key2-value2成功，所以对于一定要在setnx执行之前，对key2进行过期检查）

**三、Redis采用的过期策略**

惰性删除+定期删除

1. 惰性删除流程

1.
  1. 在进行get或setnx等操作时，先检查key是否过期，
  2. 若过期，删除key，然后执行相应操作；
  3. 若没过期，直接执行相应操作

1. 定期删除流程（简单而言，对指定个数个库的每一个库随机删除小于等于指定个数个过期key）

1.
  1. 遍历每个数据库（就是redis.conf中配置的&quot;database&quot;数量，默认为16）

1.
  1.
    1. 检查当前库中的指定个数个key（默认是每个库检查20个key，注意相当于该循环执行20次，循环体时下边的描述）

1.
  1.
    1.
      1. 如果当前库中没有一个key设置了过期时间，直接执行下一个库的遍历
      2. 随机获取一个设置了过期时间的key，检查该key是否过期，如果过期，删除key
      3. 判断定期删除操作是否已经达到指定时长，若已经达到，直接退出定期删除。

**四、RDB对过期key的处理**

过期key对RDB没有任何影响

1. 从内存数据库持久化数据到RDB文件

1.
  1. 持久化key之前，会检查是否过期，过期的key不进入RDB文件

1. 从RDB文件恢复数据到内存数据库

1.
  1. 数据载入数据库之前，会对key先进行过期检查，如果过期，不导入数据库（主库情况）

**五、AOF对过期key的处理**

过期key对AOF没有任何影响

1. 从内存数据库持久化数据到AOF文件：

1.
  1. 当key过期后，还没有被删除，此时进行执行持久化操作（该key是不会进入aof文件的，因为没有发生修改命令）
  2. 当key过期后，在发生删除操作时，程序会向aof文件追加一条del命令（在将来的以aof文件恢复数据的时候该过期的键就会被删掉）

1. AOF重写

1.
  1. 重写时，会先判断key是否过期，已过期的key不会重写到aof文件
